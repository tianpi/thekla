/**
 * @file   Client.cpp
 * @author Christian Pirchheim
 *
 * @brief  Implementation of class @c Client
 */

#include "Client.h"

#include <common/Log.h>
#include <common/TypeConverter.h>
#include <common/QtObjectUtils.h>
#include <common/DatabaseConn.h>

#include <xml/XmlSubDocument.h>
#include <xml/XmlDocument.h>

#include <Inventor/SoDB.h>
#include <QApplication>

namespace THEKLA {

//================================================================================

/**
 * @class Client
 *
 * @brief Frontend API of Thekla.
 *
 *
 * @b Declaration
 *
 * Creating a Thekla client, the user must specify the actual application environment,
 * choosing between:
 *
 * @li QT_APP: Qt (GUI or console) application that is driven by a Qt main event loop (see
 * QApplication::exec() method). Example: Studierstube (Coin3D) application using the SoQt
 * viewer, Qt 2D GUI application
 *
 * @li NON_QT_APP: Any other type of (GUI or console) application based on some other
 * toolkit than Qt. Example: Studierstube application using the SoWin viewer running under
 * Win32
 *
 * Example (Client is employed within a Qt GUI application):
 * @verbatim
 Client client(Client::QT_APP);
 @endverbatim
 *
 *
 * @b Initialization
 *
 * Each Client must be initialized using one of the init() member functions:
 *
 * @b init(QString,QString,int,int): The first parameter specifies the @e appliation @e id
 * which identifies a @c TheklaUIData XML element uniquely within the Muddleware database
 * that is defined by rest of the parameters.
 *
 * Example (connecting to Muddleware database at localhost referencing to application id
 * @c AppId):
 *
 * @verbatim
 client.init("AppId", "localhost", 20000, 20001);
 @endverbatim
 *
 * @b init(QFile,QObject*,bool): The first parameter specifies the location of a
 * Thekla configuration file (eg generated by the Thekla Qt Designer plugin). This
 * initializer is designed to be employed within Qt applications as the second parameter
 * must be the @e main @e container object of a Qt GUI (either of type QMainWindow, or
 * QDialog, or QWidget). Together with the main container object the contents of the
 * configuration file specify some connection setup between observable objects and the
 * database (@e application @e id and @e server @e settings are stored in the config file)
 * that is established without any additional work. The third (optional) parameter
 * signifies the startup policy when selecting XML representations from the database (also
 * see below): either (default case, parameter value @e false) the local observable
 * object's state is inserted into the database or (parameter value @e true) - in case a
 * corresponding database entry already exists - the local object's state is overwritten
 * by the database entry contents (and thus @e recovered in reference to a - assumed -
 * previous execution session of the same application).
 *
 * Example (Loading a configuration file from the CWD and passing the main container of a
 * Qt dialog application @c QDialog, recovering observable states from database):
 *
 * @verbatim
 QFile configFile("Dialog-thekla.xml");
 client.init(configFile, Dialog, true);
 @endverbatim
 *
 * @b Usage
 *
 * After initialization, the client can be basically used in two ways: As @e selection @e
 * tool of database entries and as @e insertion @e tool of observable objects into the
 * database.
 *
 * @b (1) Insert and Bind Observable (Object -> DB)
 *
 * In order to publish local objects to other applications via the Muddleware database,
 * such an @e observable object (QObject property or signal method or OIV SoField) must
 * first be @e inserted into the database, what allows allows Thekla to @e bind the
 * object, meaning: Thekla establishes some means, that keeps the local object state
 * synchronous with the database for the duration of the application runtime. Here, Thekla
 * creates an XML representation of the observable object in the first step, inserts this
 * string into the database, and furthermore updates this representation to reflect
 * changes of the local observable object.
 *
 * This workflow is established by calling one of the insert() methods first, which return
 * an abstract DOM object (the XML representation) of the local observable object and then
 * calling the appropriate bind() method.
 *
 * Example (insert and bind a OIV SoField: the position of the SoQt viewer camera):
 *
 * @verbatim
 OivField * oivCamera = client.insertOivField(&(viewer->getCamera()->position), "cameraPosition", true);
 clientIn.bindOivField(oivCamera);
 @endverbatim
 *
 *
 * @b (2) Select and Connect to Observer (DB -> Object)
 *
 * In order to receive events from a distant @e observable object via the Muddleware
 * database, the XML representation of the observable object must first be @e selected
 * from the database, and can then be @e connected to some compatible local @e observer
 * object. Following, Thekla keeps the observer synchronous with the connected database
 * entry.
 *
 * Selecting is done by calling one of the select() methods, which return an DOM object
 * representing the XML representation of the distant observable object. The DOM object
 * and the observer object is then passed to one of the connect() methods, indicating
 * Thekla to establish a connection between the database entry and the local observer
 * object. Any change in the database is forwarded to the observer using asychronous
 * Muddleware watchdogs.
 *
 * Example (continuation of the above example: selecting the camera position and connect
 * it to the @c QLabel object property @c text):
 *
 * @verbatim
 OivField * cameraPos = client.selectOivField("SFVec3f", "cameraPos");
 client.connectOivFieldToQtProperty(cameraPos, label, "text");
 @endverbatim
 *
 *
 *
 * @b Fine @b Tuning
 *
 *
 * The Thekla DB read/write operations may sometimes consume so much processing time, that
 * the performance of employing 3D applications is badly influenced. The 'why' is easily
 * explained with the above example of the camera position of a 3D Viewer which is bound
 * as observable: Per default, Thekla synchronizes the observable XML representation
 * within the database as often as the observable object state changes. Now, when examing
 * an object in the 3D viewer, the camera position changes continuously, resulting in
 * continuous updates of the database.
 *
 * The client offers methods allowing to adjust the DB read/write update rate:
 *
 *
 * @b (I) Customize Read/Write Interval
 *
 * @b setWriteInterval(timeout): The @e timeout is interpreted as milliseconds value
 * and indicates the desired database update frequency. Thus, for example, putting @e
 * timeout to @c 100, only each 100 milliseconds, the observable state is sychronized with
 * the database.
 *
 * @b setReadInterval(timeout): Analogous for the select frequency. Only each @e
 * timeout milliseconds, any local observer object is synchronized with its connected to
 * database entry.
 *
 * Both @e timeout values can be set to zero or greater. When zero, updates and selects
 * are executed immediately without queuing events (most accurate, highest CPU
 * requirements, highest network traffic). Any @e timeout value greater than zero prompts
 * Thekla to use timers which perform updating and selecting in intervals, and queuing
 * input/output events.
 *
 * Hence, CPU resources are saved, network traffic is reduced and the Muddleware server
 * itself, which also takes is share of CPU time when running locally on the same machine,
 * is disburdened, hopefully resulting in a better performance of the target 3D
 * application.
 *
 *
 * @b (II) Manual control
 *
 * For the application programmer it is possible to enable/disable update/select
 * operations manually.
 *
 * @b enableWriting(enable): When @e enable is set @c false, then no sychronization
 * updates are sent to the database.
 *
 * @b enableReading(enable): Analogous for selecting. While @e enable is set to @c false,
 * pending Watchdog events are ignored.
 *
 * The current state of read/write can be questioned with the corresponding isEnabled()
 * methods.
 *
 * The following methods may help the application programmer to implement manual means to
 * control Thekla:
 *
 * @b notifyOnDbChange(): A @c SoSFTrigger is passed which is touched each time the local
 * database changes due to the arrival of a Watchdog event (DB -> Object).
 *
 * The intention was to offer the OIV application programmer a hook: the @c SoSFTrigger
 * can be applied to field sensor, whose callback body may call one the above Thekla fine
 * tune methods (eg enable/disable read/write) depending on the current 3D application
 * state.
 */

//--------------------------------------------------------------------------------
/**
 *
 *
 * @param appType
 */
Client::Client(AppType appType)
    : isInitialized_(false),
      appType_(appType),
      clientLog_(clientLog),
      dbConn_(NULL),
      dbEventDispatcher_(NULL),
      dbDoc_(NULL)
{
    //// Initialize THEKLA

    // Init Logging (log4cplus)
    if (!Log::isInitialized()) {
        Log::init();
    }

    // Create QApplication singleton instance
    if (QApplication::instance() == NULL) {
        int argc = 1;
        char * argv[] = { "" };
        QApplication * qAppInstance = new QApplication(argc, argv); // , QApplication::Tty);
        Q_UNUSED(qAppInstance);
    }

    // Create QApplication singleton instance
    if (QApplication::instance() == NULL) {
        int argc = 0;
        char * argv[] = { "" };
        bool guiEnabled = false;
        QApplication * qAppInstance = new QApplication(argc, argv, guiEnabled);
        Q_UNUSED(qAppInstance);
    }

    // Init Coin meta database
    if (!SoDB::isInitialized())
        SoDB::init();

    // Init Qt <-> Coin type conversion
    TypeConverter::init();

    // Init event dispatcher objects
    DatabaseEventDispatcher::init();

}

//--------------------------------------------------------------------------------
/**
 *
 *
 */
Client::~Client()
{
    dbEventDispatcher_->removeTargetDbConn(dbConn_);
    DatabaseConnManager::release(dbConn_);

    if (dbDoc_ != NULL) delete dbDoc_;

    THEKLA_INFO(clientLog_, "Client terminated normally.");
}

//--------------------------------------------------------------------------------
void Client::initEnd()
{
    isInitialized_ = true;
    THEKLA_INFO(clientLog_, "Client successfully intialized.");
}

//--------------------------------------------------------------------------------
void Client::initLog(const QString & appId)
{
    // Init Log
    clientLog_ = Log::getClientLog(appId);
    Exception::setLog(Log::getChildLog(clientLog, "Exception"));
}

//--------------------------------------------------------------------------------
void Client::initDbConn(const QString & serverHost, int serverPort, int serverCBPort)
{
    //// Init database connection

    if (dbConn_ == NULL) {

        DatabaseConn::Info dbConnInfo(serverHost, serverPort, serverCBPort);
        dbConn_ = DatabaseConnManager::acquire(dbConnInfo);

    }

    //// Init database event dispatching

    switch (appType_) {

    case QT_APP:
        dbEventDispatcher_ = DatabaseEventDispatcher::qtAppEventDispatcher;
        break;

    case NON_QT_APP:
        dbEventDispatcher_ = DatabaseEventDispatcher::nonQtAppEventDispatcher;
        break;

    default:
        THROW_THEKLA_EXCEPTION("Invalid application type (" << appType_ << ").");
        break;

    };

    dbEventDispatcher_->addTargetDbConn(dbConn_);
}

//--------------------------------------------------------------------------------
void Client::init(const QString & appId,
                  const QString & serverHost, int serverPort, int serverCBPort,
                  const QString & uiDataRootXPathPrefix)
{

    try {

        if (isInitialized_) return;

        initLog(appId);

        initDbConn(serverHost, serverPort, serverCBPort);

        dbDoc_ = new XmlDatabaseDocument(*dbConn_);
        dbDoc_->init(appId, uiDataRootXPathPrefix);

        initEnd();

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within init()." << endl;
        stream << "Parameters:" << endl;
        stream << "appId (" << appId << ")." << endl;
        stream << "serverHost (" << serverHost << ")." << endl;
        stream << "serverPort (" << serverPort << ")." << endl;
        stream << "serverCBPort (" << serverCBPort << ")." << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

//--------------------------------------------------------------------------------
void Client::init(QFile & configFile, QObject * qObjectMainContainer, bool recoverFromDb)
{
    try {

        if (isInitialized_) return;

        //// create ConfigFileDocument from given file

        XmlConfigFileDocument configFileDoc;
        configFileDoc.init();
        configFileDoc.load(configFile);

        UIDataRoot * uiDataRoot = configFileDoc.getUIDataRoot();
        UISettings * uiSettings = configFileDoc.getUISettings();

        //// init client and DatabaseDocument with ConfigFileDocument

        initLog(uiDataRoot->getAppId());
        initDbConn(uiSettings->getServerHost(),
                   uiSettings->getServerPort(),
                   uiSettings->getServerCallbackPort());

        dbDoc_ = new XmlDatabaseDocument(*dbConn_);
        dbDoc_->init(configFileDoc, recoverFromDb);

        //// merge elements from DOM with Observables

        if (qObjectMainContainer == NULL) {
            THROW_THEKLA_EXCEPTION("Given main container QObject pointer value is NULL.");
        }

        if (qObjectMainContainer->objectName() != uiDataRoot->getAppId())
        {
            QString errMsg;
            QTextStream stream(&errMsg, QIODevice::WriteOnly);
            stream << "Given main container QObject does not match Document configuration:" << endl;
            stream << "(1) Object name must be '" << uiDataRoot->getAppId() << "')" << endl;
            THROW_THEKLA_EXCEPTION(errMsg);

        }

        //// Merge document with main container QObject

        dbDoc_->mergeDocument(qObjectMainContainer, recoverFromDb);
        dbDoc_->updateDocument();

        //// Apply configuration settings

        dbDoc_->applyConfiguration();

        initEnd();

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within init(QFile)." << endl;
        stream << "Parameters:" << endl;
        stream << "QFile (filename = " << configFile.fileName() << ")." << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}


//================================================================================

//--------------------------------------------------------------------------------
QtObject* Client::insertQtObject(QObject * qObj, bool recoverFromDb)
{
    try {

        Observable qObjObs(qObj);
        // find existing element
        XmlElement * qtObj = dbDoc_->findElementExtended(qObjObs);

        // create and add element
        if (qtObj == NULL) {

            XmlSubDocument subDoc = dbDoc_->createSubDocument(qObjObs);
            qtObj = subDoc.getRootElement();
            dbDoc_->addElement(qtObj, recoverFromDb);
        }

        if (recoverFromDb) {
            dbDoc_->syncObservableSubDocument(qtObj);
        }

        QtObject * ret = dynamic_cast<QtObject*>(qtObj);
        return ret;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within insertQtObject()." << endl;
        stream << "Parameters:" << endl;
        stream << "QObject (className = " << qObj->metaObject()->className() << ", objectName = " << qObj->objectName() << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//--------------------------------------------------------------------------------
QtSignal* Client::bindQtSignal(QtObject * qtObject, const QString & signature)
{
    try {

        QtSignal * qtSignal = qtObject->getSignal(signature);

        if (qtSignal == NULL) {

            //// create QtSignal element

            const Observable * qtObjObs = qtObject->getObservable();
            if (qtObjObs == NULL) {
                THROW_THEKLA_EXCEPTION("Requested QtSignal does not (yet) exist. "
                                      << "Creating the QtSignal failed, "
                                      << "because given QtObject does not have a QObject Observable.");
            }

            // retrieve QSignal observable
            QObject * qObj;
            qtObjObs->getObservable(qObj);
            // NOTE: throws Exception if no Method exists for that signature
            QMetaMethod qSignal = QtObjectUtils::getMetaMethod(*qObj, signature.toAscii());

            // create element with factory (tag name)
            XmlElement * qtSignalElem = dbDoc_->getElement("QtSignal");
            // init with retrieved Observable
            qtSignalElem->init(new Observable(qObj, qSignal));

            // add as child of given QtObject
            qtSignalElem->setParent(qtObject);
            // insert into DOM
            dbDoc_->addElement(qtObject);

            qtSignal = dynamic_cast<QtSignal*>(qtSignalElem);

        }

        qtSignal->bind();

        return qtSignal;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within bindQtSignal()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtObject (className = " << qtObject->getClassName() << ", objectName = " << qtObject->getObjectName() << ")" << endl;
        stream << "QSignal (signature = " << signature << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//--------------------------------------------------------------------------------
QtProperty* Client::bindQtProperty(QtObject * qtObject, const QString & propertyName)
{
    try {

        QtProperty * qtProperty = qtObject->getProperty(propertyName);

        if (qtProperty == NULL) {

            //// (Try to) create QtProperty element

            const Observable * qtObjObs = qtObject->getObservable();
            if (qtObjObs == NULL) {
                THROW_THEKLA_EXCEPTION("Requested QtProperty does not (yet) exist. "
                                      << "Creating the QtProperty failed, "
                                      << "because given QtObject does not have a QObject Observable.");
            }

            // retrieve QProperty observable
            QObject * qObj;
            qtObjObs->getObservable(qObj);
            // NOTE: throws Exception if no Property exists for that NAME
            QMetaProperty qProperty = QtObjectUtils::getMetaProperty(*qObj, propertyName.toAscii());

            // create element with factory (tag name)
            XmlElement * qtPropertyElem = dbDoc_->getElement("QtProperty");
            // init with retrieved Observable
            qtPropertyElem->init(new Observable(qObj, qProperty));

            // add as child of given QtObject
            qtPropertyElem->setParent(qtObject);
            // insert into DOM
            dbDoc_->addElement(qtObject);

            qtProperty = dynamic_cast<QtProperty*>(qtPropertyElem);
        }

        qtProperty->bind();

        return qtProperty;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within bindQtProperty()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtObject (className = " << qtObject->getClassName() << ", objectName = " << qtObject->getObjectName() << ")" << endl;
        stream << "QProperty (name = " << propertyName << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//--------------------------------------------------------------------------------
OivField* Client::insertOivField(SoField * observable, const QString & fieldName,
                                   bool recoverFromDb)
{
    try {

        if (fieldName.isEmpty()) {
            THROW_THEKLA_EXCEPTION("OivField name must not be EMPTY.");
        }

        Observable oivObs(observable);
        // find existing element
        XmlElement * oivFieldElem = dbDoc_->findElementExtended(oivObs);
        OivField * oivField = dynamic_cast<OivField*>(oivFieldElem);

        // create new element
        if (oivField == NULL || oivField->getName() != fieldName) {

            oivFieldElem = dbDoc_->getElement("OivField");
            oivFieldElem->init(new Observable(observable));

            // set OivField identifier
            oivField = dynamic_cast<OivField*>(oivFieldElem);
            oivField->setName(fieldName);

            dbDoc_->addElement(oivFieldElem, recoverFromDb);
        }

        if (recoverFromDb) {
            dbDoc_->syncObservableSubDocument(oivFieldElem);
        }

        return oivField;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within insertOivField()." << endl;
        stream << "Parameters:" << endl;
        stream << "SoField (type = " << observable->getTypeId().getName().getString() << ")" << endl;
        stream << "Identifier (fieldName = " << fieldName << ")" <<  endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//--------------------------------------------------------------------------------
OivField* Client::bindOivField(OivField * oivField)
{
    try {

        oivField->bind();
        return oivField;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within bindOivField()." << endl;
        stream << "Parameters:" << endl;
        stream << "OivField (type = " << oivField->getType() << ", name = " << oivField->getName() << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//================================================================================


//--------------------------------------------------------------------------------
QtObject * Client::selectQtObject(const QString & qClassName, const QString & qObjName)
{
    try {

        // get (primary) key for the element (attribute names and values)
        XmlElementData qtObjectKey = QtObject::getKey(qClassName, qObjName);
        qtObjectKey.setTagName("QtObject");

        //// add dummy elements to document

        XmlElement * qtObjectElem = dbDoc_->findFirstElement(qtObjectKey);

        if (qtObjectElem == NULL) {

            //// create dummy (QtObject) element

            // create element with factory (tag name)
            qtObjectElem = dbDoc_->getElement("QtObject");
            // merge key xml data with (default) xml data
            qtObjectElem->merge(qtObjectKey);

            //// add dummy elements to document

            dbDoc_->addElement(qtObjectElem);

        }

        //// merge dummy element with database contents. NOTE: Works ONLY AFTER adding the
        //// elements to the document. Otherwise the XPath is incomplete.

        qtObjectElem->merge(dbDoc_->getDatabaseConn());

        QtObject * qtObject = dynamic_cast<QtObject*>(qtObjectElem);
        if (qtObject == NULL) {
            THROW_THEKLA_EXCEPTION("Cannot dynamic_cast Element to QtObject.");
        }

        return qtObject;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within selectQtObject()." << endl;
        stream << "Parameters:" << endl;
        stream << "className = " << qClassName << ", objectName = " << qObjName << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}


//--------------------------------------------------------------------------------
QtSignal * Client::selectQtSignal(QtObject * qtObject,
                                        const QString & qSignalSignature)
{
    try {

        // get (primary) key for the element (attribute names and values)
        XmlElementData qtSignalKey = QtSignal::getKey(qSignalSignature);
        qtSignalKey.setTagName("QtSignal");

        //// add dummy elements to document

        XmlElement * qtSignalElem = qtObject->findFirstElement(qtSignalKey);

        if (qtSignalElem == NULL) {

            //// create dummy (QtSignal) element

            // create element with factory (tag name)
            qtSignalElem = dbDoc_->getElement("QtSignal");
            // merge key xml data with (default) xml data
            qtSignalElem->merge(qtSignalKey);

            //// add dummy elements to document

            qtSignalElem->setParent(qtObject);
            dbDoc_->addElement(qtObject);

        }

        //// merge dummy element with database contents. NOTE: Works ONLY AFTER adding the
        //// elements to the document. Otherwise the XPath is incomplete.

        qtSignalElem->merge(dbDoc_->getDatabaseConn());

        QtSignal * qtSignal = dynamic_cast<QtSignal*>(qtSignalElem);
        if (qtSignal == NULL) {
            THROW_THEKLA_EXCEPTION("Cannot dynamic_cast Element to QtSignal");
        }

        return qtSignal;


    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within selectQtSignal()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtObject (className  = " << qtObject->getClassName() << ", objectName = " << qtObject->getObjectName() << ")" << endl;
        stream << "QSignal (signature = " << qSignalSignature << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;

}

//--------------------------------------------------------------------------------
QtProperty * Client::selectQtProperty(QtObject * qtObject,
                                            const QString & qPropertyName, const QString & qPropertyType)
{
    try {

        // get (primary) key for the element (attribute names and values)
        XmlElementData qtPropertyKey = QtProperty::getKey(qPropertyName, qPropertyType);
        qtPropertyKey.setTagName("QtProperty");

        //// add dummy elements to document

        XmlElement * qtPropertyElem = qtObject->findFirstElement(qtPropertyKey);

        if (qtPropertyElem == NULL) {

            //// create dummy (QtProperty) element

            // create element with factory (tag name)
            qtPropertyElem = dbDoc_->getElement("QtProperty");
            // merge key xml data with (default) xml data
            qtPropertyElem->merge(qtPropertyKey);

            //// add dummy elements to document

            qtPropertyElem->setParent(qtObject);
            dbDoc_->addElement(qtObject);

        }

        //// merge dummy element with database contents. NOTE: Works ONLY AFTER adding the
        //// elements to the document. Otherwise the XPath is incomplete.

        qtPropertyElem->merge(dbDoc_->getDatabaseConn());

        QtProperty * qtProperty = dynamic_cast<QtProperty*>(qtPropertyElem);
        if (qtProperty == NULL) {
            THROW_THEKLA_EXCEPTION("Cannot dynamic_cast Element to QtProperty");
        }

        return qtProperty;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within selectQtProperty()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtObject (className" << qtObject->getClassName() << ", objectName = " << qtObject->getObjectName() << ")" << endl;
        stream << "QProperty (name = " << qPropertyName << ", type = " << qPropertyType << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;

}

//--------------------------------------------------------------------------------
OivField * Client::selectOivField(const QString & oivClassType, const QString & oivObjName)
{
    try {

        // get (primary) key for the element (attribute names and values)
        XmlElementData oivFieldKey = OivField::getKey(oivClassType, oivObjName);
        oivFieldKey.setTagName("OivField");

        //// find element within document

        XmlElement * oivFieldElem = dbDoc_->findFirstElement(oivFieldKey);

        if (oivFieldElem == NULL) {

            //// create dummy (OivField) element

            // create element with factory (tag name)
            oivFieldElem = dbDoc_->getElement("OivField");
            // merge key xml data with (default) xml data
            oivFieldElem->merge(oivFieldKey);

            //// add dummy elements to document

            dbDoc_->addElement(oivFieldElem);

        }

        //// merge dummy element with database contents. NOTE: Works ONLY AFTER adding the
        //// elements to the document. Otherwise the XPath is incomplete.

        oivFieldElem->merge(dbDoc_->getDatabaseConn());

        OivField * oivField = dynamic_cast<OivField*>(oivFieldElem);
        if (oivField == NULL) {
            THROW_THEKLA_EXCEPTION("Cannot dynamic_cast Element to OivField");
        }

        return oivField;

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within selectQtProperty()." << endl;
        stream << "Parameters:" << endl;
        stream << "oivClassType = " << oivClassType << ", oivObjName = " << oivObjName << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

    return NULL;
}

//--------------------------------------------------------------------------------
void Client::connectQtSignalToQtSlot(QtSignal * qtSignal,
                                           QObject * qObj, const QString & qSlotSignature)
{
    try {

        //// check actual parameters

        if (qObj->metaObject()->indexOfSlot(qSlotSignature.toAscii()) == -1) {
            THROW_THEKLA_EXCEPTION("Given QObject method signature (" << qSlotSignature >> ") is not a valid slot signature.")
        }

        //// Connect the QtSignal to the Observer

        QMetaMethod qSlot = QtObjectUtils::getMetaMethod(*qObj, qSlotSignature.toAscii());
        Observer qObjObs(qObj, qSlot);

        qtSignal->connect(new Observer(qObjObs));


    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectQtSignalToQtSlot()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtSignal (signature = " << qtSignal->getSignature() << ")" << endl;
        stream << "QObject (className = " << qObj->metaObject()->className() << ", objectName = " << qObj->objectName() << ")" << endl;
        stream << "QSlot (signature = " << qSlotSignature << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

//--------------------------------------------------------------------------------
void Client::connectQtPropertyToQtProperty(QtProperty * qtProperty,
                                                 QObject * qObj, const QString & qPropertyName)
{
    try {

        //// check actual parameters

        if (qObj->metaObject()->indexOfProperty(qPropertyName.toAscii()) == -1) {
            THROW_THEKLA_EXCEPTION("Given QObject property name (" << qPropertyName >> ") is invalid.")
        }

        //// Connect the QtProperty to the Observer

        QMetaProperty qProperty = QtObjectUtils::getMetaProperty(*qObj, qPropertyName.toAscii());
        Observer qObjObs(qObj, qProperty);

        qtProperty->connect(new Observer(qObjObs));

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectQtPropertyToQtProperty()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtProperty (name = " << qtProperty->getName() << ", type = " << qtProperty->getType() << ")" << endl;
        stream << "QObject (className = " << qObj->metaObject()->className() << ", objectName = " << qObj->objectName() << ")" << endl;
        stream << "QProperty (name = " << qPropertyName << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

//--------------------------------------------------------------------------------
void Client::connectOivFieldToQtProperty(OivField * oivField,
                                         QObject * qObj, const QString & qPropertyName)
{
    try {

        //// check actual parameters

        if (qObj->metaObject()->indexOfProperty(qPropertyName.toAscii()) == -1) {
            THROW_THEKLA_EXCEPTION("Given Observer QObject Property name '" << qPropertyName << "' invalid.");
        }

        QMetaProperty qProperty = QtObjectUtils::getMetaProperty(*qObj, qPropertyName.toAscii());
        Observer qObjObs(qObj, qProperty);

        oivField->connect(new Observer(qObjObs));


    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectOivFieldToQtProperty()." << endl;
        stream << "Parameters:" << endl;
        stream << "OivField (type = " << oivField->getType() << ", name = " << oivField->getName() << ")" << endl;
        stream << "QObject (className = " << qObj->metaObject()->className() << ", objectName = " << qObj->objectName() << ")" << endl;
        stream << "QProperty (name = " << qPropertyName << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

//--------------------------------------------------------------------------------
void Client::connectQtPropertyToOivField(QtProperty * qtProperty,
                                         SoField * field)
{
    try {

        Observer observer(field);
        qtProperty->connect(new Observer(observer));

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectQtPropertyToOivField()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtProperty (name = " << qtProperty->getName() << ", type = " << qtProperty->getType() << ")" << endl;
        stream << "SoField (type = " << field->getTypeId().getName().getString() << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

//--------------------------------------------------------------------------------
void Client::connectQtSignalToOivFieldList(QtSignal * qtSignal,
                                           SoFieldList * fieldList)
{
    try {

        Observer observer(fieldList);
        qtSignal->connect(new Observer(observer));

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectQtSignalToOivFieldList()." << endl;
        stream << "Parameters:" << endl;
        stream << "QtSignal (signature = " << qtSignal->getSignature() << ")" << endl;
        stream << "SoFieldList (length = " << fieldList->getLength() << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }

}

//--------------------------------------------------------------------------------
void Client::connectOivFieldToOivField(OivField * oivField,
                                       SoField * field)
{
    try {

        //// check actual parameters

        if (field == NULL) {
            THROW_THEKLA_EXCEPTION("Given SoField has pointer value NULL.");
        }

        Observer observer(field);

        oivField->connect(new Observer(observer));

    } catch (std::exception & ex) {

        QString errMsg;
        QTextStream stream(&errMsg, QIODevice::WriteOnly);
        stream << "Exception within connectOivFieldToOivField()." << endl;
        stream << "Parameters:" << endl;
        stream << "OivField (type = " << oivField->getType() << ", name = " << oivField->getName() << ")" << endl;
        stream << "SoField (type = " << field->getTypeId().getName().getString() << ")" << endl;
        stream << "Exception:" << endl;
        stream << ex.what() << endl;
        THEKLA_ERROR(clientLog_, errMsg.toStdString());

        // re-throw the exception
        throw Exception(errMsg.toStdString());
    }
}

} // namespace THEKLA


